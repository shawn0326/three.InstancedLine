// github.com/shawn0326/three.instancedline
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{})}(this,(function(t){"use strict";function e(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function n(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,r(t,e)}function r(t,e){return(r=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var i=[-1,1,0,1,1,0,-1,-1,0,1,-1,0],o=[-1,1,1,1,-1,-1,1,-1],c=[0,2,1,2,3,1],a=function(t){function e(){var e;return(e=t.call(this)||this).type="InstancedLineGeometry",e.setIndex(c),e.setAttribute("position",new THREE.Float32BufferAttribute(i,3)),e.setAttribute("uv",new THREE.Float32BufferAttribute(o,2)),e}n(e,t);var r=e.prototype;return r.setFromPoints=function(t){var e=[],n=t.length;t.forEach((function(t,r){e.push(t.x,t.y,t.z),0!==r&&r!==n-1||e.push(t.x,t.y,t.z)}));var r=new THREE.InstancedInterleavedBuffer(new Float32Array(e),3,1);return r.count-=3,this.setAttribute("instancePrev2",new THREE.InterleavedBufferAttribute(r,3,0)),this.setAttribute("instancePrev1",new THREE.InterleavedBufferAttribute(r,3,3)),this.setAttribute("instanceNext1",new THREE.InterleavedBufferAttribute(r,3,6)),this.setAttribute("instanceNext2",new THREE.InterleavedBufferAttribute(r,3,9)),this.computeBoundingBox(),this.computeBoundingSphere(),this},r.computeBoundingBox=function(){},r.computeBoundingSphere=function(){},e}(THREE.InstancedBufferGeometry),u=function(t){function r(){return t.call(this,{type:"InstancedLineMaterial",defines:{DISABLE_CORNER_BROKEN:!1},uniforms:{resolution:{value:new THREE.Vector2(512,512)},lineWidth:{value:2},cornerThreshold:{value:.4},opacity:{value:1},color:{value:new THREE.Color}},vertexShader:"\nattribute vec3 instancePrev2;\nattribute vec3 instancePrev1;\nattribute vec3 instanceNext1;\nattribute vec3 instanceNext2;\n\nuniform float lineWidth;\nuniform vec2 resolution;\n\nuniform float cornerThreshold;\n\nvoid trimSegment(const in vec4 start, inout vec4 end) {\n\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t// conservative estimate of the near plane\n\t\tfloat a = projectionMatrix[2][2]; // 3nd entry in 3th column\n\t\tfloat b = projectionMatrix[3][2]; // 3nd entry in 4th column\n\t\tfloat nearEstimate = -0.5 * b / a;\n\n\t\tfloat alpha = (nearEstimate - start.z) / (end.z - start.z);\n\n\t\tend.xyz = mix(start.xyz, end.xyz, alpha);\n}\n\nvoid main() {\n\t\tfloat aspect = resolution.x / resolution.y;\n\t\tfloat flagY = position.y * 0.5 + 0.5;\n\n\t\t// camera space\n\t\tvec4 prev = modelViewMatrix * vec4(mix(instancePrev2, instancePrev1, flagY), 1.0);\n\t\tvec4 curr = modelViewMatrix * vec4(mix(instancePrev1, instanceNext1, flagY), 1.0);\n\t\tvec4 next = modelViewMatrix * vec4(mix(instanceNext1, instanceNext2, flagY), 1.0);\n\n\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\tbool perspective = (projectionMatrix[2][3] == -1.0); // 4th entry in the 3rd column\n\n\t\tif (perspective) {\n\t\t\t\tif (position.y < 0.) {\n\t\t\t\t\t\tif (curr.z < 0.0 && next.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(curr, next);\n\t\t\t\t\t\t} else if (next.z < 0.0 && curr.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(next, curr);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (prev.z < 0.0 && curr.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(prev, curr);\n\t\t\t\t\t\t} else if (curr.z < 0.0 && prev.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(curr, prev);\n\t\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\tif (prev.z < 0.0 && curr.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(prev, curr);\n\t\t\t\t\t\t} else if (curr.z < 0.0 && prev.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(curr, prev);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (curr.z < 0.0 && next.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(curr, next);\n\t\t\t\t\t\t} else if (next.z < 0.0 && curr.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(next, curr);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\t\n\t\t}\n\n\t\t// clip space\n\t\tvec4 clipPrev = projectionMatrix * prev;\n\t\tvec4 clipCurr = projectionMatrix * curr;\n\t\tvec4 clipNext = projectionMatrix * next;\n\n\t\t// ndc space\n\t\tvec2 ndcPrev = clipPrev.xy / clipPrev.w;\n\t\tvec2 ndcCurr = clipCurr.xy / clipCurr.w;\n\t\tvec2 ndcNext = clipNext.xy / clipNext.w;\n\n\t\t// direction\n\t\tvec2 dir, dir1, dir2;\n\t\tfloat w = 1.0;\n\n\t\tif (prev == curr) {\n\t\t\t\tdir = ndcNext - ndcCurr;\n\t\t\t\tdir.x *= aspect;\n\t\t\t\tdir = normalize(dir);\n\t\t} else if(curr == next) {\n\t\t\t\tdir = ndcCurr - ndcPrev;\n\t\t\t\tdir.x *= aspect;\n\t\t\t\tdir = normalize(dir);\n\t\t} else {\n\t\t\t\tdir1 = ndcCurr - ndcPrev;\n\t\t\t\tdir1.x *= aspect;\n\t\t\t\tdir1 = normalize(dir1);\n\n\t\t\t\tdir2 = ndcNext - ndcCurr;\n\t\t\t\tdir2.x *= aspect;\n\t\t\t\tdir2 = normalize(dir2);\n\n\t\t\t\tdir = normalize(dir1 + dir2);\n\n\t\t\t\tw = dot(dir1, dir);\n\n\t\t\t\t#ifdef DISABLE_CORNER_BROKEN\t\n\t\t\t\t\t\tw = 1.0 / max(w, cornerThreshold);\n\t\t\t\t#else\n\t\t\t\t\t\tfloat flagT = step(w, cornerThreshold);\n\t\t\t\t\t\tw = 1.0 / mix(w, 1.0, flagT);\n\t\t\t\t\t\tdir = mix(dir, mix(dir2, dir1, flagY), flagT);\n\t\t\t\t#endif\n\t\t}\n\n\t\t// perpendicular to dir\n\t\tvec2 offset = vec2(dir.y, -dir.x);\n\n\t\t// undo aspect ratio adjustment\n\t\toffset.x /= aspect;\n\n\t\t// sign flip\n\toffset *= float(sign(position.x));\n\n\t\t// adjust for lineWidth\n\t\toffset *= lineWidth * w;\n\t\t\n\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\toffset /= resolution.y;\n\t\t\n\t\t// select end\n\t\tvec4 clip = clipCurr;\n\n\t\t// back to clip space\n\t\toffset *= clip.w;\n\n\t\tclip.xy += offset;\n\n\t\tgl_Position = clip;\n}\n",fragmentShader:"\nuniform float opacity;\nuniform vec3 color;\n\nvoid main() {\n\t\tgl_FragColor = vec4(color, opacity);\n}\n"})||this}var i,o,c;return n(r,t),i=r,(o=[{key:"lineWidth",get:function(){return this.uniforms.lineWidth.value},set:function(t){this.uniforms.lineWidth.value=t}},{key:"cornerThreshold",get:function(){return this.uniforms.cornerThreshold.value},set:function(t){this.uniforms.cornerThreshold.value=t}},{key:"opacity",get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms&&(this.uniforms.opacity.value=t)}},{key:"color",get:function(){return this.uniforms.color.value},set:function(t){this.uniforms&&(this.uniforms.color.value=t)}}])&&e(i.prototype,o),c&&e(i,c),r}(THREE.ShaderMaterial),s=function(t){function e(){var e,n=new a,r=new u;return(e=t.call(this,n,r)||this).type="InstancedLine",e.frustumCulled=!1,e}return n(e,t),e}(THREE.Mesh);t.InstancedLine=s,Object.defineProperty(t,"__esModule",{value:!0})}));
