// github.com/shawn0326/three.instancedline
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{})}(this,(function(t){"use strict";function n(t,n){for(var e=0;e<n.length;e++){var r=n[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function e(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,r(t,n)}function r(t,n){return(r=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}var i=[-1,1,0,1,1,0,-1,-1,0,1,-1,0],a=[0,1,1,1,0,0,1,0],o=[0,2,1,2,3,1],s=new THREE.Vector3;var u=function(t){function n(){var n;return(n=t.call(this)||this).type="InstancedLineGeometry",n.setIndex(o),n.setAttribute("position",new THREE.Float32BufferAttribute(i,3)),n.setAttribute("uv",new THREE.Float32BufferAttribute(a,2)),n}e(n,t);var r=n.prototype;return r.setFromPoints=function(t,n){var e=n&&n.length>0,r=[],i=t.length,a=0;t.forEach((function(o,s){if(s>0&&(a+=o.distanceTo(t[s-1])),e){var u=0;(n.indexOf(s)>-1||n.indexOf(s+1)>-1)&&(u=1),r.push(o.x,o.y,o.z,a,u),0!==s&&s!==i-1||r.push(o.x,o.y,o.z,a,u)}else r.push(o.x,o.y,o.z,a),0!==s&&s!==i-1||r.push(o.x,o.y,o.z,a)}));var o=e?5:4,s=new THREE.InstancedInterleavedBuffer(new Float32Array(r),o,1);return s.count=Math.max(0,s.count-3),this.setAttribute("instancePrev2",new THREE.InterleavedBufferAttribute(s,3,0*o)),this.setAttribute("instancePrev1",new THREE.InterleavedBufferAttribute(s,3,1*o)),this.setAttribute("instanceNext1",new THREE.InterleavedBufferAttribute(s,3,2*o)),this.setAttribute("instanceNext2",new THREE.InterleavedBufferAttribute(s,3,3*o)),this.setAttribute("instancePrevDist",new THREE.InterleavedBufferAttribute(s,1,1*o+3)),this.setAttribute("instanceNextDist",new THREE.InterleavedBufferAttribute(s,1,2*o+3)),e&&(this.setAttribute("instancePrevBreak",new THREE.InterleavedBufferAttribute(s,1,1*o+4)),this.setAttribute("instanceNextBreak",new THREE.InterleavedBufferAttribute(s,1,2*o+4))),delete this._maxInstanceCount,this.computeBoundingBox(),this.computeBoundingSphere(),this},r.computeBoundingBox=function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);var t=this.attributes.instancePrev1;void 0!==t&&t.data.count>0?function(t,n){for(var e=1/0,r=1/0,i=1/0,a=-1/0,o=-1/0,s=-1/0,u=0,c=n.count+2;u<c;u++){var f=n.array[u*n.stride+0],l=n.array[u*n.stride+1],d=n.array[u*n.stride+2];f<e&&(e=f),l<r&&(r=l),d<i&&(i=d),f>a&&(a=f),l>o&&(o=l),d>s&&(s=d)}t.min.set(e,r,i),t.max.set(a,o,s)}(this.boundingBox,t.data):this.boundingBox.makeEmpty()},r.computeBoundingSphere=function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere),null===this.boundingBox&&this.computeBoundingBox();var t=this.attributes.instancePrev1;if(void 0!==t&&t.data.count>0){var n=this.boundingSphere.center;this.boundingBox.getCenter(n);for(var e=0,r=0,i=t.data.count+2;r<i;r++)s.fromArray(t.data.array,r*t.data.stride),e=Math.max(e,n.distanceToSquared(s));this.boundingSphere.radius=Math.sqrt(e),isNaN(this.boundingSphere.radius)&&console.error("THREE.InstancedLineGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}else this.boundingSphere.makeEmpty()},n}(THREE.InstancedBufferGeometry),c=THREE.ShaderChunk.logdepthbuf_vertex.replace("vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) )","vIsPerspective = isPerspectiveMatrix( projectionMatrix ) ? 1.0 : 0.0"),f="\n#include <common>\n\nattribute vec3 instancePrev2;\nattribute vec3 instancePrev1;\nattribute vec3 instanceNext1;\nattribute vec3 instanceNext2;\n\nattribute float instancePrevDist;\nattribute float instanceNextDist;\n\n#ifdef LINE_BREAK\n\t\tattribute float instancePrevBreak;\n\t\tattribute float instanceNextBreak;\n\n\t\tvarying float vDiscard;\n#endif\n\nuniform float lineWidth;\nuniform vec2 resolution;\n\nuniform float cornerThreshold;\n\nuniform mat3 uvTransform;\nvarying vec2 vUv;\n\n#ifdef USE_ALPHAMAP\n\t\tuniform mat3 uvTransform1;\n\t\tvarying vec2 vAlphaUv;\n#endif\n\nvoid trimSegment(const in vec4 start, inout vec4 end) {\n\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t// conservative estimate of the near plane\n\t\tfloat a = projectionMatrix[2][2]; // 3nd entry in 3th column\n\t\tfloat b = projectionMatrix[3][2]; // 3nd entry in 4th column\n\t\tfloat nearEstimate = -0.5 * b / a;\n\n\t\tfloat alpha = (nearEstimate - start.z) / (end.z - start.z);\n\n\t\tend.xyz = mix(start.xyz, end.xyz, alpha);\n}\n\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n\t\tfloat aspect = resolution.x / resolution.y;\n\t\tfloat flagY = position.y * 0.5 + 0.5;\n\n\t\t// camera space\n\t\tvec4 prev = modelViewMatrix * vec4(mix(instancePrev2, instancePrev1, flagY), 1.0);\n\t\tvec4 curr = modelViewMatrix * vec4(mix(instancePrev1, instanceNext1, flagY), 1.0);\n\t\tvec4 next = modelViewMatrix * vec4(mix(instanceNext1, instanceNext2, flagY), 1.0);\n\n\t\t#ifdef LINE_BREAK\n\t\t\t\tvDiscard = instancePrevBreak * instanceNextBreak;\n\t\t\t\tif (position.y > 0.0 && instanceNextBreak > 0.5) {\n\t\t\t\t\t\tnext = curr;\n\t\t\t\t} else if (position.y < 0.0 && instancePrevBreak > 0.5) {\n\t\t\t\t\t\tprev = curr;\n\t\t\t\t}\n\t\t#endif\n\n\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\tbool perspective = (projectionMatrix[2][3] == -1.0); // 4th entry in the 3rd column\n\n\t\tif (perspective) {\n\t\t\t\tif (position.y < 0.) {\n\t\t\t\t\t\tif (curr.z < 0.0 && next.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(curr, next);\n\t\t\t\t\t\t} else if (next.z < 0.0 && curr.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(next, curr);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (prev.z < 0.0 && curr.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(prev, curr);\n\t\t\t\t\t\t} else if (curr.z < 0.0 && prev.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(curr, prev);\n\t\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\tif (prev.z < 0.0 && curr.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(prev, curr);\n\t\t\t\t\t\t} else if (curr.z < 0.0 && prev.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(curr, prev);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (curr.z < 0.0 && next.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(curr, next);\n\t\t\t\t\t\t} else if (next.z < 0.0 && curr.z >= 0.0) {\n\t\t\t\t\t\t\t\ttrimSegment(next, curr);\n\t\t\t\t\t\t}\n\t\t\t\t} \n\t\t}\n\n\t\t// clip space\n\t\tvec4 clipPrev = projectionMatrix * prev;\n\t\tvec4 clipCurr = projectionMatrix * curr;\n\t\tvec4 clipNext = projectionMatrix * next;\n\n\t\t// ndc space\n\t\tvec2 ndcPrev = clipPrev.xy / clipPrev.w;\n\t\tvec2 ndcCurr = clipCurr.xy / clipCurr.w;\n\t\tvec2 ndcNext = clipNext.xy / clipNext.w;\n\n\t\t// direction\n\t\tvec2 dir, dir1, dir2;\n\t\tfloat w = 1.0;\n\n\t\tif (prev == curr) {\n\t\t\t\tdir = ndcNext - ndcCurr;\n\t\t\t\tdir.x *= aspect;\n\t\t\t\tdir = normalize(dir);\n\t\t} else if(curr == next) {\n\t\t\t\tdir = ndcCurr - ndcPrev;\n\t\t\t\tdir.x *= aspect;\n\t\t\t\tdir = normalize(dir);\n\t\t} else {\n\t\t\t\tdir1 = ndcCurr - ndcPrev;\n\t\t\t\tdir1.x *= aspect;\n\t\t\t\t\n\t\t\t\tdir2 = ndcNext - ndcCurr;\n\t\t\t\tdir2.x *= aspect;\n\n\t\t\t\tdir1 = normalize(dir1);\n\t\t\t\tdir2 = normalize(dir2);\n\n\t\t\t\tdir = normalize(dir1 + dir2);\n\n\t\t\t\tw = dot(dir1, dir);\n\n\t\t\t\t#ifdef DISABLE_CORNER_BROKEN\t\n\t\t\t\t\t\tw = 1.0 / max(w, cornerThreshold);\n\t\t\t\t#else\n\t\t\t\t\t\tfloat flagT = step(w, cornerThreshold);\n\t\t\t\t\t\tw = 1.0 / mix(w, 1.0, flagT);\n\t\t\t\t\t\tdir = mix(dir, mix(dir2, dir1, flagY), flagT);\n\t\t\t\t#endif\n\t\t}\n\n\t\t// perpendicular to dir\n\t\tvec2 offset = vec2(dir.y, -dir.x);\n\n\t\t// undo aspect ratio adjustment\n\t\toffset.x /= aspect;\n\n\t\t// sign flip\n\toffset *= float(sign(position.x));\n\n\t\t// adjust for lineWidth\n\t\toffset *= lineWidth * w;\n\t\t\n\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\toffset /= resolution.y;\n\t\t\n\t\t// select end\n\t\tvec4 clip = clipCurr;\n\n\t\t// back to clip space\n\t\toffset *= clip.w;\n\n\t\tclip.xy += offset;\n\n\t\tgl_Position = clip;\n\t\t\n\t\tvec4 mvPosition = curr;\n\t\t#include <fog_vertex>\n\t\t#include <logdepthbuf_vertex>\n\n\t\t#ifdef FLAT_W\n\t\t\t\tif (gl_Position.w > -1.0) {\n\t\t\t\t\t\tgl_Position.xyz /= gl_Position.w;\n\t\t\t\t\t\tgl_Position.w = 1.0;\n\t\t\t\t}\n\t\t#endif\n\n\t\t// uv\n\t\t// TODO trim uv\n\t\tvec2 tUv = vec2(0.0, 0.0);\n\t\t#ifdef SIMPLE_UV\n\t\t\t\ttUv = uv;\n\t\t#else\n\t\t\t\t#ifdef SCREEN_UV\n\t\t\t\t\t\ttUv = uv;\n\t\t\t\t#else\n\t\t\t\t\t\ttUv.x = uv.x;\n\t\t\t\t\t\ttUv.y = mix(instancePrevDist, instanceNextDist, flagY);\n\t\t\t\t#endif\n\t\t#endif\n\n\t\t#ifdef SWAP_UV\n\t\ttUv = tUv.yx;\n\t#endif\n\n\t\tvUv = (uvTransform * vec3(tUv, 1.)).xy;\n\t\t#ifdef USE_ALPHAMAP\n\t\t\t\tvAlphaUv = (uvTransform1 * vec3(tUv, 1.)).xy;\n\t\t#endif\n}\n".replace("#include <logdepthbuf_vertex>",c),l=function(t){function r(){var n;return(n=t.call(this,{type:"InstancedLineMaterial",defines:{LINE_BREAK:!1,DISABLE_CORNER_BROKEN:!1,FLAT_W:!1,SWAP_UV:!1,SIMPLE_UV:!1,SCREEN_UV:!1},uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,{resolution:{value:new THREE.Vector2(512,512)},lineWidth:{value:2},cornerThreshold:{value:.4},opacity:{value:1},color:{value:new THREE.Color},map:{value:null},alphaMap:{value:null},uvTransform:{value:new THREE.Matrix3},uvTransform1:{value:new THREE.Matrix3}}]),vertexShader:f,fragmentShader:"\n#include <common>\n\nuniform float opacity;\nuniform vec3 color;\n\n#include <map_pars_fragment>\n\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n\t\tvarying vec2 vAlphaUv;\n#endif\n\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\n#ifdef LINE_BREAK\n\t\tvarying float vDiscard;\n#endif\n\nvarying vec2 vUv;\n\nvoid main() {\n\t\t#ifdef LINE_BREAK\n\t\t\t\tif (vDiscard > 0.5) {\n\t\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t#endif\n\n\t\tvec4 diffuseColor = vec4(color, opacity);\n\t\t#include <map_fragment>\n\n\t\t#ifdef USE_ALPHAMAP\n\t\t\tdiffuseColor.a *= texture2D(alphaMap, vAlphaUv).g;\n\t\t#endif\n\n\t\tgl_FragColor = diffuseColor;\n\t\t#include <fog_fragment>\n\t\t#include <logdepthbuf_fragment>\n}\n"})||this).fog=!0,n}var i,a,o;return e(r,t),i=r,(a=[{key:"lineWidth",get:function(){return this.uniforms.lineWidth.value},set:function(t){this.uniforms.lineWidth.value=t}},{key:"cornerThreshold",get:function(){return this.uniforms.cornerThreshold.value},set:function(t){this.uniforms.cornerThreshold.value=t}},{key:"opacity",get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms&&(this.uniforms.opacity.value=t)}},{key:"color",get:function(){return this.uniforms.color.value},set:function(t){this.uniforms&&(this.uniforms.color.value=t)}},{key:"map",get:function(){return this.uniforms.map.value},set:function(t){this.uniforms&&(this.uniforms.map.value=t)}},{key:"uvTransform",get:function(){return this.uniforms.uvTransform.value},set:function(t){this.uniforms&&(this.uniforms.uvTransform.value=t)}},{key:"alphaMap",get:function(){return this.uniforms.alphaMap.value},set:function(t){this.uniforms&&(this.uniforms.alphaMap.value=t)}},{key:"uvTransform1",get:function(){return this.uniforms.uvTransform1.value},set:function(t){this.uniforms&&(this.uniforms.uvTransform1.value=t)}}])&&n(i.prototype,a),o&&n(i,o),r}(THREE.ShaderMaterial),d=function(t){function n(){var n,e=new u,r=new l;return(n=t.call(this,e,r)||this).type="InstancedLine",n}return e(n,t),n}(THREE.Mesh);t.InstancedLine=d,Object.defineProperty(t,"__esModule",{value:!0})}));
